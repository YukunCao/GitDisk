## [工件（软件开发）](https://github.com/YukunCao/GitDisk/blob/master/Concepts/Artifact%20(software%20development).md)

工件（Artifact），是在软件开发过程中产生的一类实际的副产物。一些工件（例如：[用例]()、[类图]()、其他[统一建模语言]()（UML）模型、依赖关系以及设计文档）用于描述软件的功能、架构和设计。其他工件则和开发过程本身相关——例如项目计划、商业案例和风险评估。

术语*工件*在软件开发领域主要和特定的开发方法或开发过程相关，比如，[统一过程]()（Unified Process）。该术语的用法也许就起源于这些开发方法。

[构建工具]()通常用工件来指代为测试而编译的源代码，因为可执行文件是执行测试不可或缺的部分。如果没有可执行文件，测试计划就只能局限在[基于非执行的测试]()。在[基于非执行的测试]()中，工件包括[程序规格覆核]()、[安全检测]()、和[正确性校验]()。而另一方面，[基于执行的测试]()需要至少两个工件：[测试套件]()和可执行文件。工件偶尔也用于指代产生的已发布的代码（对[代码库]()来说）或已发布的可执行文件（对程序来说），但是更一般的用法还是指代软件开发中的副产品，而不是软件本身。开源代码库通常包含一份[测试套件]()，以此让贡献者们可以确保对代码库的修改不会导致[回归]()[bug]()。

大部分被认为是工件的，都是[软件文档]()。

在[终端用户开发]()中，工件是由终端用户所创建的一个应用程序和一个复杂的数据对象，这里的终端用户没必要知道通用的编程语言。这些工件描述自动化行为或者控制序列，例如数据库请求、语法规则或者用户生成的内容。

工件之间的区别在它的可维护性上。可维护性主要受工件所承担的角色所影响。这里的角色可以是实际的，也可以是象征性的。在软件开发的早期阶段，工件也许由设计团队创建来适配一个象征性的角色，以向资助商展示在满足项目的需求上承包商的认真态度。象征性的工件通常不能充分传达信息，但确能令人印象深刻。在信息架构行业，象征性的工件有时也被称为“被照亮的目录”，因为其修饰性并不能对认知起到增进的作业。一般来说，“被照亮的目录”被认为是不可维护的，因为要确保它的象征质量需要不断的劳作。由于这个原因，所展示的“被照亮的目录”一旦被资助商批准，它们便会被适配实际角色的工件所替代。实际的工件通常需要在项目的整个生命周期中维护，也正因如此，它们通常是高可维护的。

从[项目管理]()的角度看，作为[可交付件]()，工件是非常有意义的。一个软件项目的可交付件可以看作是其工件加上软件本身。

工件指代副产品的感觉，类似于术语[伪影]()在科学领域中指代一些在受控过程中产生的异常，而不是问题本身。换言之，侧重于是由设备所造成的外加产物，而非最终所呈现出来的结果。

可以利用[软件开发文件夹]()来收集、组织和管理工件。